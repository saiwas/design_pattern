# 设计模式 #
## 前言 ##
> 很久很久前研究过C#版设计模式,时间太久远,渐渐地忘记了, 借着学ruby的机会,重新学习一下。
********

### 面向对象的好处 ###
      1) 通过封装,继承,多态把程序的耦合度降低。
      2) 用设计模式使得程序跟加灵活,容易修改,并且易于复用
********

## 简单工厂模式 ##
### 对象关系 ###
		聚合: 表示一种弱的'拥有'关系，体现的是 A 对象可以包含 B 对象, 但系 B 对象不是 A 对象的一部分。
		组合: 一种强的'拥有'关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。

#### 优点 ####
		工厂类中包含了必要的逻辑判断，根据客户端的选择动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
#### 缺点 ####
		增加功能的时候，就需要增加case的条件分支，也就是要修改工厂类，违背了“开放-封闭原则”。
********

## 策略模式 ##
		1) 定义了算法家族,分别封装起来,让他们之间可以相互替换。使得算法的变化不会影响使用的客户。
		2) 简化了单元测试,因为每个算法都有自己的类,可以通过自己的接口单独测试。
********

## 单一职责原则 ##
		1) 就一个类而言,应该仅有一个引起它变化的原因
		2) 如果能够想到多于一个的动机去改变一个类,那么这个类就多于一个的责任,应该考虑对这个类进行职责分离。(高耦合)
********

## 开放-封闭原则 ##
		1) 软件实体(类,模块,函数等等)应该可以拓展,但是不可以修改。
		2) 对于拓展是开放的, 对于更改是封闭的。
		3) 开放-封闭原则 是面向对象设计的核心所在。
		4) 可维护性,可拓展性,可重复性,灵活性好
		5) 如何设计：动是增加新的代码,而不是更改现有的代码。
			5.1) 在最初写代码时,假设变化不会发生。
			5.2) 当发生变化时,创建抽象来隔离以后发生的同类变化。
			5.3) 面对需求,对程序的改
********

## 依赖倒转原则 ##
		1) 高层模块不应该依赖低层模块。两个都应该依赖抽象。
		2) 抽象不应该依赖细节。细节应该依赖抽象。(针对接口编程，而不应该针对实现编程.)
		3) **依赖倒转原则** 是面向对象设计的标志, 用哪种语言编写程序不重要, 如果编写时考虑如何针对抽象编程而不是细节编程,那就是面向对象设计，反之,就是过程化设计。
### 里氏代换原则 ###
		1) 子类型必须能够替换掉它们的父类型。
			1.1) 只有子类可以替换父类, 功能才不受影响,父类才能真正被复用,而子类才能在父类基础上增加新的行为。
		  1.2) 由于子类型可替换父类型,所以才能使得父类模块在无需修改的情况下拓展。
********

## 装饰模式 ##
		动态地给一个对象添加一些额外的责任,就添加功能来说,装饰模式比生成子类更为灵活。
### 优点 ###
    1) 把类中的装饰功能从类中搬移去除，简化原有的类。
		2) 有效地把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。
********

## 代理模式 ##
    为其他对象提供一种代理以控制对这个对象的访问。
### 场景应用 ###
		1）远程代理  -  为一个对象在不同的地址看空间提供局部代表。可以隐藏一个对象存在于不同地址的事实。
		2）虚拟代理  -  根据需要创建开销很大的对象。通过他来存放实例化需要很长的真实对象。
		3）安全代理  -  用来控制真实对象访问时的权限。
		4）智能代理  -  当调用真实的对象时，代理处理另外一些事。
********

## 工厂模式 ##
		定义一个用于创建对象的接口,让子类决定实例化哪一个类。
		工厂方法使一个类的实例化延迟到子类。
### 工厂模式 VS 简单工厂模式 ###
    简单工厂模式: 最大的优点在于工厂类包含必要的逻辑判断,根据客户端选择的条件动态实例化相关类。
		            对于客户端来说，去掉了于具体产品的依赖。
		工厂模式   : 工厂模式实现时,客户端要决定实例化哪一个工厂来实现运算类,选择判断的问题还是存在的。
		总结      : 工厂模式 把 简单工厂模式的逻辑判断从工厂类改成客户端。
********

## 原型模式 ##
-- 待续 --
